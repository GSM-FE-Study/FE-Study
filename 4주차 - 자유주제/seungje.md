# SSR 개념 바로잡기! Server Side Rendering!!

## Server Side Rendering이 무엇일까?

server side rendering을 이해하기 위해서는 먼저, client side rendering에 대한 이해가 필요하다.

브라우저 렌더링 관련 참고 게시글.

[frorong.tistory.com](https://frorong.tistory.com/entry/%EC%99%9C-translate%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95)

### Client Side Rendering

client side rendering은 클라이언트 즉, 브라우저 측에서 렌더링을 진행한다는 것이다. HTML, CSS, JS파일이 클라이언트로 전송되고, 브라우저에서 JS를 사용하여 동적으로 페이지를 렌더링 한다.

**동작 과정**

1\. 서버는 초기에 필요한 정적 리소스를 제공한다.

2\. 클라이언트는 이 리소스들을 다운로드, 파싱 한 후에 JS를 이용하여 동적 데이터를 요청하고 받아온다.

3\. 받아온 데이터로 동적으로 페이지를 업데이트하고 렌더링 한다.

4\. 정보를 가져오기 위해 API 서버와 상호작용한다.

여기서 언급되는 서버는 실제 API 서버가 아닌 프론트엔드 서버이다.

이 과정 속에서 정적 리소스를 요청해서 응답을 받고, JS번들을 요청해서 응답을 받고, 번들을 실행하고, API서버로부터 응답을 받아야 콘텐츠를 보여줄 수 있다. 그동안 유저는 기다려야 한다.

### Server Side Rendering

server side rendering은 서버에서 웹 페이지를 완전히 렌더링 한 후에 클라이언트 측에 전달하는 방식이다. 클라이언트는 이미 완성된 HTML을 받아서 화면에 표시한다.

**동작 과정**

1\. 클라이언트의 요청이 서버에 전달된다.

2\. 서버는 필요한 데이터를 가져와 HTML을 완전히 렌더링 한다.

3\. 렌더링 된 HTML이 클라이언트로 전송되고, 클라이언트는 받은 HTML을 표시한다.

어플리케이션이 실행된 후에 보내던 API 요청을 프론트엔드 서버에서 미리 보낼 수 있다. 프론트엔드 서버와 API 서버는 물리적으로 가까이 있기 때문에 브라우저에서 API 서버로 요청을 보내는 것보다 빠른 응답을 받을 수 있다.

이제 CSR, SSR 각각의 개념과 과정을 이해했을 것이다. CSR과 SSR의 장단점을 알아보고, 어떤 상황에 필요할지 생각해 보자.

### 장단점

#### CSR

- 초기에 로딩에 필요한 최소한의 리소스만 다운로드되므로, 빠른 초기 로딩이 가능하다.
- 페이지의 일부분만 빠르게 업데이트되므로, 어플리케이션이 빠르게 반응할 수 있다.
- 검색 엔진 최적화가 어렵다.
- 초기 로딩 이후에 JS가 실행되기 때문에, 초기 로딩 이후 페이지가 완전히 나타날 수 있다.
- 클라이언트에서 캐싱을 사용하는 것이 가능하다.

#### SSR

- 검색 엔진이 서버 측에서 완전히 렌더링 된 HTML을 이해하기 쉽게 파싱할 수 있다.
- 서버에서 이미 렌더링된 HTML을 전달하므로, 초기에 사용자가 페이지를 빠르게 볼 수 있다.
- 초기 로딩 속도가 느릴 수 있다.
- 서버가 각 요청에 대해 페이지를 렌더링 하고 데이터를 처리함으로, 많은 사용자가 동시에 접속 시 서버에 부담이 될 수 있다.

여기서 초기 로딩과, 페이지 표시는 다른 개념이다.

예를 들면 여기 img 태그 하나가 있다.

```html
<img src="https://blabla" alt="image" />
```

CSR에서는 img 태그 자체는 빠르게 로딩된다. 이미지의 자리가 확보되고 화면의 구조가 구성되는 것이다. 하지만 이미지의 내용이 페이지에 보여지는 것과는 별개이다. SSR에서는 이미 HTML이 렌더링 되어 클라이언트에 전달되므로, 이미지의 내용까지 한 번에 보여진다.

### 사용 권장 상황

#### CSR

- 인터렉티브 한 사용자 경험이 필요한 경우.
- 어플리케이션이 복잡하고 대규모인 경우.
- 검색엔진 최적화가 필요 없는 경우.

#### SSR

- 검색엔진 최적화가 필요한 경우.
- 최초 로딩이 빨라야 하는 경우.
- 어플리케이션의 상호작용이 많이 필요하지 않은 경우.

### 구현

CSR은 일반적인 SPA프레임워크에서 주로 사용된다. SSR은 어떨까?

SSR을 쉽게 구현하기 위해선 NextJS를 사용할 수 있다. NextJS는 기본적으로 SSR을 지원한다. NextJS 12 버전에서는 server side fetch를 위해 getInitialProps나 getServerSideProps 같은 방법을 사용할 수 있었다. NextJS 13 버전에서는 fetch 메서드를 사용하여 server side fetch를 할 수 있다.

## 마치며

무조건 SSR이 좋은 게 아니다. 각 상황에 따라 적합한 방식을 사용해야 한다. 블로그를 작성하며 알게 되었는데, 나는 SSR과 RSC의 개념을 혼동하고 있었다. 일단 SSR과 CSR의 개념을 적립하였으니, 다음에는 RSC와 RCC의 개념을 적립해야겠다.

## Reference

[joshua1988.github.io](https://joshua1988.github.io/vue-camp/nuxt/ssr.html#%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3-%E1%84%89%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3-%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC)

<iframe src="https://www.youtube.com/embed/IKyA8BKxpXc" width="300" height="169" frameborder="0" allowfullscreen="true"></iframe>
